<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8">
    <title>Game Multiplayer</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name='viewport' content='user-scalable=0' />

    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap" rel="stylesheet">

    <style>
      body{
        margin: 0;
        margin-top: -4px;
      }

      @import url('https://fonts.googleapis.com/css2?family=Nunito:ital,wght@1,700&display=swap');
      
      .float-top-left{
        position: absolute;
        margin: 2px 0 0 7px;
        top: 0;
        left: 0;
        z-index: 9999;
        color: rgba(255,255,255,1);
      
        font-family: 'Nunito', sans-serif;
        font-size: 22px;
      }
    </style>

    <script src="/socket.io/socket.io.js"></script>
    <script src="//code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
    <script>const socket = io();</script>
    
  </head>
  <body>
    <p class="float-top-left">Score: <span id="score">0</span></p>
    <canvas id="game-area"></canvas>
    
      
    <script>
      //Import the game area
      const canvas = document.getElementById('game-area');

      canvas.width = innerWidth
      canvas.height = innerHeight
      const ctx = canvas.getContext('2d')

      //Import the score text
      const scoreUI = document.getElementById('score')
      let score = 0; 
      let AddToScore = 0;

      function updateScore(){
        
          if(score < AddToScore){
            score += 10
            requestAnimationFrame(updateScore)
          }else{
            score = AddToScore;
            cancelAnimationFrame(updateScore)
          }

          scoreUI.innerHTML = score
       }
      

      // prefabs or class {}
      class playerPrefab {
        constructor(x, y, radius, color){ 
          this.x = x
          this.y = y
          this.radius = radius
          this.color = color
        }

        draw(){
        ctx.beginPath()
        ctx.fillStyle = this.color 
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false)
        ctx.fill()
        }
      }

      class enemyPrefab {
        constructor(x, y, radius, color, target, velocity){ 
          this.x = x
          this.y = y
          this.radius = radius
          this.color = color
          this.target = target

          this.velocity = velocity
          this.speed = 0
          this.angle = 0
        }

        draw(){
          ctx.beginPath()
          ctx.fillStyle = this.color 
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false)
          ctx.fill()
        }

        update() {
          this.draw()

          this.angle = Math.atan2(
          (this.target.y) - this.y, 
          (this.target.x) - this.x)

          this.speed = {
           x: Math.cos(this.angle) * this.velocity,
           y: Math.sin(this.angle) * this.velocity
          }

          this.x = this.x + this.speed.x
          this.y = this.y + this.speed.y
        }
      }

      class particlePrefab {
        constructor(x, y, radius, color, speed){ 
          this.x = x
          this.y = y
          this.radius = radius
          this.color = color
          this.speed = speed
          this.apha = 1

          this.friction = 0.98
        }

        draw(){
          ctx.save()
          ctx.globalAlpha = this.apha
          ctx.beginPath()
          ctx.fillStyle = this.color 
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false)
          ctx.fill()
          ctx.restore()
        }

        update() {
          this.draw()
          this.speed.x *= this.friction
          this.speed.y *= this.friction
          this.x = this.x + this.speed.x
          this.y = this.y + this.speed.y
          this.apha -= 0.015
        }
      }


      class shootPrefab {
        constructor (x,y,radius,color,speed){
          this.x = x
          this.y = y
          this.radius = radius
          this.color = color
          this.speed = speed
        }

        draw(){
          ctx.beginPath()
          ctx.fillStyle = this.color 
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false)
          ctx.fill()
        }

        update() {
          this.draw() 
          this.x = this.x + this.speed.x
          this.y = this.y + this.speed.y
        }
      }
      // END: prefabs

      const player = new playerPrefab((canvas.width / 2),(canvas.height / 2)
      ,10,'white')
      
      const enemies = []
      const shoots = []
      const particles = []

      function spawnEnemys() {
        setInterval( () => {
          
          const color = `hsl(${Math.random() * 360}, 50%, 50%)`
          const velocity = 0.9

          const radius = Math.random() * (30 - 6) + 6
          
          const pos = {
            x: 0, 
            y: 0
          }

          if(Math.random() > 0.5){
            pos.x = Math.random()  < 0.5 ? 0 - radius : canvas.width + radius
            pos.y = Math.random() * canvas.height
          }else{
            pos.x =  Math.random() * canvas.width
            pos.y = Math.random()  < 0.5 ? 0 - radius : canvas.width + radius
          }
          const targetInitial = {
            x: player.x, 
            y: player.y
          }
          
          enemies.push(new enemyPrefab(
            pos.x, pos.y, radius, color,targetInitial, velocity))
        }, 1200)
  
      }

      // Print a frame or animate()
      function animate() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.1)" 
        ctx.fillRect(0,0,canvas.width,canvas.height)
        
        player.draw()

        particles.forEach((particle, pIndex) =>{
          if(particle.apha < 0){
            particles.splice(pIndex, 1)
          }else{
            particle.update()
          }
        })

        shoots.forEach((shoot, sIndex) => {
          shoot.update()

          // Remove the shoot if outside of screen
          if(
            shoot.x - shoot.radius < 0 || 
            shoot.x - shoot.radius > canvas.width ||
            shoot.y - shoot.radius < 0 ||
            shoot.y - shoot.radius > canvas.height
          ){
            shoots.splice(sIndex, 1)
          }
        })

        enemies.forEach((enemy, eIndex) => {
          enemy.update()

          const distPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y)

          // Game Over
          if(distPlayer - enemy.radius - player.radius < 1)
          {
            cancelAnimationFrame(animate)
          }

           // Check the collision between shots and enemies
          shoots.forEach((shoot , sIndex) => {
    
            const dist = Math.hypot(shoot.x - enemy.x, shoot.y - enemy.y)

            if(dist - enemy.radius - shoot.radius < 1)
            {

              const angle = Math.atan2(
                shoot.y - enemy.y, 
                shoot.x - enemy.x)
              
              
              for(let i=0; i < enemy.radius; i++){

                //Emit particles if collision
                particles.push(new particlePrefab(
                  shoot.x,shoot.y, Math.random() * 2.3 , enemy.color, {
                    x: (-enemy.speed.x) + shoot.speed.x * (Math.random() -0.5)  / 2.3,
                    y: (-enemy.speed.y) + shoot.speed.x * (Math.random() -0.5) / 2.3
                    }
                ))
              }
                 
              
              if(enemy.radius -10 > 10)
              {
                AddToScore += 50
                updateScore()

                gsap.to(enemy, {
                radius: enemy.radius -10
                })
            
                setTimeout(() => {
                  shoots.splice(sIndex, 1)
                }, 0)
              }else{
                AddToScore += 100
                score += 20
                updateScore()

                setTimeout(() => {
                  enemies.splice(eIndex, 1)
                  shoots.splice(sIndex, 1)
                }, 0)
              }
            }
          })
        })
        requestAnimationFrame(animate)
      }

      // Listen to user clicks
      addEventListener('click', (event) => {
        const angle = Math.atan2(
          event.clientY - canvas.height / 2, 
          event.clientX - canvas.width / 2)
        
        const speed = {
            x: Math.cos(angle) * 8,
            y: Math.sin(angle) * 8
        }
        shoots.push(new shootPrefab(
            canvas.width / 2, 
            canvas.height / 2, 
            4,'white', speed
        ))
      })

     //Start animation and spawn
      animate()
      spawnEnemys()

    //Diconnect
    socket.on('max-connections-error', (message) =>{
      alert(message)
      socket.disconnect()
    })
    </script>
  </body>
</html>