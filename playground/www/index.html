<!DOCTYPE html>
<html lang="pt-BR">

<head>
	<meta charset="utf-8">
	<title>Jogo Multiplayer</title>

	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="0" />
	<meta name='viewport' content='user-scalable=0' />

	<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap" rel="stylesheet">

	<style>
		* {
			font-family: 'Nunito', sans-serif;
		}

		body {
			cursor: pointer;
			margin: 0;
			margin-top: -4px;
			background: #fff;
			user-select: none;
		}
    #speed{
      position: absolute;
      top: 0;
      left: 0;
      color: rgba(255,255,255,1);

      font-size: 12px;
    }
	</style>

	<script src="/socket.io/socket.io.js"></script>
	<script src="//code.jquery.com/jquery-3.5.1.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
	<script>
		const socket = io();
	</script>

</head>

<body>

	<canvas id="game-area"></canvas>
  <div id="speed">
    <p>Velocidade: <span id="vel"></span></p>
  </div>

	<script type="module">
    // Import Scripts
    import createPlanets from './createPlanets.js'
    
		//Import <canvas> and HTML context
    const canvas = document.getElementById('game-area')
    canvas.width = innerWidth
    canvas.height = innerHeight

    const ctx    = canvas.getContext('2d')

    const planet = createPlanets(ctx)
    planet.spawPlanets(2, 600)

    //Import UI
    const velUI = document.getElementById('vel')

    const cam = {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
      follow: function (target) {
          this.x = target.x - (canvas.width/2) 
          this.y = target.y - (canvas.height/2)
      }
    }

     // Game Prefabs
    class ship {
      constructor (position, size, rotation, turnSpeed, thrustSpeed,friction) {
        this.x = position.x
        this.y = position.y
        this.rotation = rotation
        this.radius = (size / 2)
        this.radian =  (this.rotation / 180 * Math.PI)
        this.turn = turnSpeed

        this.thrusting = false,
        this.decrease =  false,
        this.rotate = 'none',
        this.thrustSpeed = thrustSpeed == undefined? 5 : thrustSpeed
        this.thrust = {x: 0, y: 0}
        this.friction = friction == undefined? 0.45 : friction
      }

      move()
      {
        this.x = this.x + this.thrust.x
        this.y = this.y + this.thrust.y
      }

      engine()
      {
        if(this.thrusting)
        {
          this.thrust.x = this.thrust.x + this.thrustSpeed * Math.cos(this.radian) / fps
          this.thrust.y = this.thrust.y - this.thrustSpeed * Math.sin(this.radian) / fps
        }else if(!this.decrease){
          this.thrust.x -= this.friction * this.thrust.x / fps
          this.thrust.y -= this.friction * this.thrust.y / fps
        }else if(this.decrease){
          this.thrust.x = this.thrust.x - this.thrustSpeed * Math.cos(this.radian) / (fps*2)
          this.thrust.y = this.thrust.y + this.thrustSpeed * Math.sin(this.radian) / (fps*2)
        }

        this.move()
      }
    }

    class engineParticle {
        constructor(x, y, radius, colors, speed, alphaRate, friciton){ 
          this.x = x
          this.y = y
          this.radius = radius
          this.colors = colors == undefined? ['red', 'yellow'] : colors
          this.speed = speed
          this.apha = 1
          this.alphaRate = alphaRate

          this.friction = friciton == undefined? 0.98 : friciton
        }

        draw(){
          ctx.save()
          ctx.globalAlpha = this.apha
          ctx.beginPath()
          ctx.fillStyle = Math.random() < 0.5? this.colors[0] : this.colors[1] 
          
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false)
          ctx.fill()
          ctx.restore()
        }

        update() {
          this.draw()
          this.speed.x *= this.friction
          this.speed.y *= this.friction
          this.x = this.x + this.speed.x
          this.y = this.y + this.speed.y
          this.apha -= this.alphaRate
        }
    }

    //Create Game Objects
    const playerShip = new ship({
      x: canvas.width/2, 
      y: canvas.height/2
    }, 20, 90, 360, 2, 0.1)

    const particles = []

    //Settings
    const fps = 60
    const animation = setInterval(update, 1000 / fps)

    // Animation Function
    function update()
    { 
      ctx.save()
      //Space update
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)' 
      ctx.fillRect(0,0,7000,7000)
      ctx.restore()


      //UI Update
      velUI.innerHTML = -Math.floor((playerShip.thrust.x * playerShip.thrust.y), -1)

      //Camera Update
      cam.follow(playerShip)
      ctx.setTransform(1, 0, 0, 1, -cam.x, -cam.y);

      ctx.beginPath()
      
      ctx.save()
      planet.planets[0].draw()
      console.log(playerShip.x, playerShip.y)
      ctx.restore()
     
      //Ships update
      drawShip(playerShip)
      moveShip(playerShip)
      engineParticles(playerShip)
    }

    function drawShip (ship)
    { 

      ctx.lineWidth = ship.size / 20 
      ctx.strokeStyle = 'white'
      ctx.fillStyle = 'white'
      
      
      ctx.moveTo(
        ship.x + 4 / 3 * (ship.radius * Math.cos(ship.radian)), 
        ship.y - 4 / 3 * (ship.radius * Math.sin(ship.radian))
      )

      ctx.lineTo(
        ship.x - ship.radius * (2 /3 * Math.cos(ship.radian) + Math.sin(ship.radian)), 
        ship.y + ship.radius * (2 /3 * Math.sin(ship.radian) - Math.cos(ship.radian))
      )

      ctx.lineTo(
        ship.x - ship.radius * (2 /3 * Math.cos(ship.radian) - Math.sin(ship.radian)), 
        ship.y + ship.radius * (2 /3 * Math.sin(ship.radian) + Math.cos(ship.radian))
      )

      if(ship.x < 0 - ship.radius){
        ship.x = 6000
      }
      if(ship.x > 6000 + ship.radius){
        ship.x = 0
      }
      if(ship.y < 0 - ship.radius){
        ship.y = 6000
      }
      if(ship.y > 6000 + ship.radius){
        ship.y = 0
      }

      ctx.closePath()
      ctx.stroke()
      ctx.fill()
      
    }

    function engineParticles (ship)
    { 
       //Particles update
      particles.forEach((particle, i) => {
        if(particle.apha < 0){
          particles.splice(i, 1)
        }else{
          particle.update()
        }
      })

      // Main Engine
      if(ship.thrusting)
      {

        const posX = ship.x - ship.radius * 4 /3 * Math.cos(ship.radian)
        const posY = ship.y + ship.radius * 4 /3 * Math.sin(ship.radian)
        
        for(let i = 0; i < 5; i++){

          particles.push(new engineParticle(
            posX + Math.random(), posY + Math.random(), Math.random() * (7 - (ship.thrust.x + ship.thrust.y) / 10), 
            ['rgb(32, 159, 233)', 'rgb(149, 208, 247)'], 
            {x: posX - (ship.x + ship.thrust.x) + Math.random()* 2, y: posY - (ship.y + ship.thrust.y) + Math.random() * 2}, 
            0.4 * (Math.random() + 0.5)
          ))
        }
      }

      if(ship.decrease)
      {
        const posX = ship.x + ship.radius * 4 /3 * Math.cos(ship.radian) * 1.2
        const posY = ship.y - ship.radius * 4 /3 * Math.sin(ship.radian) * 1.2

        for(let i = 0; i < 5; i++){

          particles.push(new engineParticle(
            posX, posY, Math.random() * (3 - (ship.thrust.x + ship.thrust.y) / 10), 
            ['#ededed', '#c4c4c4'], 
            {x: posX - (ship.x + ship.thrust.x) + Math.random()* 2, y: posY - (ship.y + ship.thrust.y) + Math.random() * 2}, 
            0.9 * (Math.random() + 0.5), 0.39
          ))
        }
      }

      //Rotate Engines
      if(ship.rotation != 0){
        const offset = ship.rotation > 0? - 80 : 80
        const posX =  ship.x + 4 / 3 * (ship.radius * Math.cos(ship.radian+offset))
        const posY =  ship.y - 4 / 3 * (ship.radius * Math.sin(ship.radian+offset))

        for(let i = 0; i < 5; i++){

          particles.push(new engineParticle(
            posX, posY, Math.random() * (3), 
            ['#ededed', '#c4c4c4'], 
            {x: posX - (ship.x + ship.thrust.x) - Math.random(), y: posY - (ship.y + ship.thrust.y) - Math.random()}, 
            0.9 * (Math.random() + 0.5), 0.28
          ))
        }
      }
    }

    // Game Controller
    const controller = {
      increaseSpeed : false,
      decreaseSpeed : false,
      rotateLeft : false,
      rotateRight : false,
      
      listen: function(command){
        let isPressed = command.type === 'keydown'?  true : false
      
        switch(command.keyCode){
          case 87:
            controller.increaseSpeed = isPressed
            break
          case 65:
            console.log('1')
            controller.rotateLeft = isPressed
            break
          case 68:
            console.log('2')
            controller.rotateRight = isPressed
			      break
			    case 83:
			      controller.decreaseSpeed = isPressed
			      break
			  }
			}
    }

    document.addEventListener('keydown', controller.listen)
    document.addEventListener('keyup', controller.listen)


    function moveShip (ship)
    {
      if(controller.increaseSpeed){
        ship.thrusting = true
      }else{
        ship.thrusting = false
      }
      if(controller.decreaseSpeed){
        ship.decrease = true
      }else{
         ship.decrease = false
      } 
      if(controller.rotateLeft){
        ship.rotation =  ship.turn / 180 * Math.PI / (fps * 1.2)
      }
      if(controller.rotateRight){
        ship.rotation = - ship.turn / 180 * Math.PI / (fps * 1.2)
      }

      if(!controller.rotateLeft && !controller.rotateRight){
        ship.rotation = 0
      }

      ship.radian = ship.radian + ship.rotation
      ship.engine()
    }

    update()

    //Diconnect
    socket.on('max-connections-error', (message) =>{
      alert(message)
      ocket.disconnect()
    })
	</script>
</body>

</html>