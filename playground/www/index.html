<!DOCTYPE html>
<html lang="pt-BR">

<head>
	<meta charset="utf-8">
	<title>Jogo Multiplayer</title>

	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="0" />
	<meta name='viewport' content='user-scalable=0' />

	<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap" rel="stylesheet">

	<style>
		* {
			font-family: 'Nunito', sans-serif;
		}

		body {
			cursor: pointer;
			margin: 0;
			margin-top: -4px;
			background: #fff;
			user-select: none;
		}
    #speed{
      position: absolute;
      top: 0;
      left: 0;
      color: #fff;
      line-height: 0.4;

      font-size: 12px;
    }
    .color-red{
      color: rgb(156, 30, 30);
    }
    .color-green{
      color: rgb(30, 156, 59);
    }
	</style>

	<!--<script src="/socket.io/socket.io.js"></script>-->
	<script src="//code.jquery.com/jquery-3.5.1.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
  <script>
		//const socket = io(); Temporally
	</script>

</head>

<body>

	<canvas id="game-area"></canvas>
  <div id="speed">
    <p>Posição Espacial:</p>
    <p class="color-red">X: <span id="posX"></span></p>
    <p class="color-green">Y: <span id="posY"></span></p>
    <div id="GravCampAlert">
      <p id="campAlt"></p>
    </div>
  </div>

	<script type="module">
    import createMap from './map.js'
    import makeGravity from './gravity.js'

		// Import <canvas> and HTML context
    const canvas = document.getElementById('game-area')
    canvas.width = innerWidth
    canvas.height = innerHeight
    const ctx    = canvas.getContext('2d')

    // Import game map
    const mapSize = {width: 10000, height: 10000}
    const map = createMap(ctx, mapSize)
    map.spawPlanets(4, 300)

    // Import UI
    const posUI = {
      x: document.getElementById('posX'),
      y: document.getElementById('posY')
    }
    const campAlert = {
      box: document.getElementById('GravCampAlert'),
      alt: document.getElementById('campAlt')
    }

    const cam = {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
      follow: function (target) {
          this.x = target.x - (canvas.width/2)
          this.y = target.y - (canvas.height/2)
      }
    }

    // Game Prefabs
    class ship {
      constructor (position, size, rotation, turnSpeed, thrustSpeed,friction) {
        this.x = position.x
        this.y = position.y
        this.rotation = rotation
        this.radius = (size / 2)
        this.radian =  (this.rotation / 180 * Math.PI)
        this.turn = turnSpeed

        this.thrusting = false,
        this.decrease =  false,
        this.rotate = 'none',
        this.thrustSpeed = thrustSpeed == undefined? 5 : thrustSpeed
        this.thrust = {x: 0, y: 0}
        this.friction = friction == undefined? 0.45 : friction

        this.mass = this.radius * 2
        this.velocity = {x:0,y:0}
        this.theta = 0
        this.orbitHeight = 0
        this.dirCorretion = {x: 0, y: 0},
        this.Orbiting = []
      }

      move()
      {
        this.x = this.x + this.thrust.x
        this.y = this.y + this.thrust.y

        this.x = this.x + this.velocity.x
        this.y = this.y + this.velocity.y
      }

      engine()
      {
        if(this.thrusting)
        {
          this.thrust.x = this.thrust.x + this.thrustSpeed * Math.cos(this.radian) / fps
          this.thrust.y = this.thrust.y - this.thrustSpeed * Math.sin(this.radian) / fps
        }else if(!this.decrease){
          //this.thrust.x -= this.friction * this.thrust.x / fps Disabled.
          //this.thrust.y -= this.friction * this.thrust.y / fps Gravity doesn't work with that
        }else if(this.decrease){
          this.thrust.x = this.thrust.x - this.thrustSpeed * Math.cos(this.radian) / (fps*2)
          this.thrust.y = this.thrust.y + this.thrustSpeed * Math.sin(this.radian) / (fps*2)
        }
        this.move()
      }
    }

    class engineParticle {
      constructor(x, y, radius, colors, speed, alphaRate, friciton){
        this.x = x
        this.y = y
        this.radius = radius
        this.colors = colors == undefined? ['red', 'yellow'] : colors
        this.speed = speed
        this.apha = 1
        this.alphaRate = alphaRate
        this.friction = friciton == undefined? 0.98 : friciton
      }
      draw(){
        ctx.save()
        ctx.globalAlpha = this.apha
        ctx.beginPath()
        ctx.fillStyle = Math.random() < 0.5? this.colors[0] : this.colors[1]

        ctx.arc(this.x, this.y, this.radius <0? this.radius * -1: this.radius, 0, Math.PI*2, false)
        ctx.fill()
        ctx.restore()
      }
      update() {
        this.draw()
        this.speed.x *= this.friction
        this.speed.y *= this.friction
        this.x = this.x + this.speed.x
        this.y = this.y + this.speed.y
        this.apha -= this.alphaRate
      }
    }

    //Create Game Objects
    const playerShip = new ship({
      x: canvas.width/2,
      y: canvas.height/2
    }, 20, 90, 360, 2, 0.1)

    const spaceShips = []
    const particles = []
    //Settings
    const fps = 30
    const animation = setInterval(update, 1000 / fps)


    spaceShips.push(playerShip)

     const otherShip = new ship({
      x: canvas.width/2,
      y: canvas.height/2
    }, 20, 90, 360, 2, 0.1)


    // Animation Function

    function update()
    {

      // Space update
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'
      ctx.fillRect(0,0,mapSize.width,mapSize.height)

      // Ships update
      drawShip(playerShip)
      moveShip(playerShip)
      engineParticles(playerShip)

      // Camera update
      cam.follow(playerShip)
      ctx.setTransform(1, 0, 0, 1, -cam.x, -cam.y);

       // Map update

      map.planets.forEach((planet, index) => {
         const dist = Math.hypot(Math.sqrt((planet.x - playerShip.x) ** 2 + (planet.y - playerShip.y) ** 2))
          if(dist-planet.radius < planet.orbitRange)
          {
            playerShip.Orbiting.push(planet);
            campAlert.alt.innerHTML = 'Altitude: '+ (dist - planet.radius).toFixed(1) + ' Km'
          }else if(playerShip.Orbiting.length == 0){
            campAlert.alt.innerHTML = ''
          }
        planet.draw()
      })
      playerShip.Orbiting = []
      console.log(playerShip.Orbiting.length)

      //Gravity Updates
      spaceShips.forEach((ship) => {
        map.planets.forEach((planet) => {
          const dist = Math.hypot(Math.sqrt((planet.x - ship.x) ** 2 + (planet.y - ship.y) ** 2))
          if(dist-planet.radius < planet.orbitRange)
          {
            makeGravity(playerShip, planet)
          }
        })
      })

      //UI Update
      posUI.x.innerHTML = (playerShip.thrust.x + playerShip.velocity.x).toFixed(2) + ' Km/s'
      posUI.y.innerHTML = (playerShip.thrust.y + playerShip.velocity.y).toFixed(2) + ' Km/s'

      ctx.beginPath()
      ctx.fillStyle = 'white'
      ctx.font = "10px Nunito"
      ctx.textAlign = 'end'
      ctx.direction = 'rtl'
      ctx.fillText(
        '< ' + playerShip.x.toFixed(1) + ' X >',
         playerShip.x - canvas.width/2 + 50,  playerShip.y
        )
      ctx.textAlign = 'center'
      ctx.fillText(
        '< ' + playerShip.y.toFixed(1) + ' Y >',
       playerShip.x, playerShip.y + canvas.height/2 -50
        )

    }

    function drawShip (ship)
    {
      ctx.beginPath()
      ctx.lineWidth = ship.size / 20
      ctx.strokeStyle = 'white'
      ctx.fillStyle = 'white'


      ctx.moveTo(
        ship.x + 4 / 3 * (ship.radius * Math.cos(ship.radian)),
        ship.y - 4 / 3 * (ship.radius * Math.sin(ship.radian))
      )

      ctx.lineTo(
        ship.x - ship.radius * (2 /3 * Math.cos(ship.radian) + Math.sin(ship.radian)),
        ship.y + ship.radius * (2 /3 * Math.sin(ship.radian) - Math.cos(ship.radian))
      )

      ctx.lineTo(
        ship.x - ship.radius * (2 /3 * Math.cos(ship.radian) - Math.sin(ship.radian)),
        ship.y + ship.radius * (2 /3 * Math.sin(ship.radian) + Math.cos(ship.radian))
      )

      if(ship.x < 0 - ship.radius){
        ship.x = mapSize.width
      }
      if(ship.x > mapSize.width + ship.radius){
        ship.x = 0
      }
      if(ship.y < 0 - ship.radius){
        ship.y = mapSize.height
      }
      if(ship.y >  mapSize.height + ship.radius){
        ship.y = 0
      }

      ctx.closePath()
      ctx.stroke()
      ctx.fill()

    }

    function engineParticles (ship)
    {
       //Particles update
      particles.forEach((particle, i) => {
        if(particle.apha < 0){
          particles.splice(i, 1)
        }else{
          particle.update()
        }
      })

      // Main Engine
      if(ship.thrusting)
      {

        const posX = ship.x - ship.radius * 4 /3 * Math.cos(ship.radian)
        const posY = ship.y + ship.radius * 4 /3 * Math.sin(ship.radian)

        for(let i = 0; i < 5; i++){

          particles.push(new engineParticle(
            posX + Math.random(), posY + Math.random(), Math.random() * (7 - (ship.thrust.x + ship.thrust.y) / 10),
            ['rgb(32, 159, 233)', 'rgb(149, 208, 247)'],
            {x: posX - (ship.x) + Math.random()* 2, y: posY - (ship.y) + Math.random() * 2},
            0.4 * (Math.random() + 0.5)
          ))
        }
      }

      if(ship.decrease)
      {
        const posX = ship.x + ship.radius * 4 /3 * Math.cos(ship.radian) * 1.2
        const posY = ship.y - ship.radius * 4 /3 * Math.sin(ship.radian) * 1.2

        for(let i = 0; i < 5; i++){

          particles.push(new engineParticle(
            posX, posY, Math.random() * (3 - (ship.thrust.x + ship.thrust.y) / 10),
            ['#ededed', '#c4c4c4'],
            {x: posX - (ship.x + ship.thrust.x) + Math.random()* 2, y: posY - (ship.y + ship.thrust.y) + Math.random() * 2},
            0.9 * (Math.random() + 0.5), 0.39
          ))
        }
      }

      //Rotate Engines
      if(ship.rotation != 0){
        const offset = ship.rotation > 0? - 80 : 80
        const posX =  ship.x + 4 / 3 * (ship.radius * Math.cos(ship.radian+offset))
        const posY =  ship.y - 4 / 3 * (ship.radius * Math.sin(ship.radian+offset))

        for(let i = 0; i < 5; i++){

          particles.push(new engineParticle(
            posX, posY, Math.random() * (3),
            ['#ededed', '#c4c4c4'],
            {x: posX - (ship.x + ship.thrust.x) - Math.random(), y: posY - (ship.y + ship.thrust.y) - Math.random()},
            0.9 * (Math.random() + 0.5), 0.28
          ))
        }
      }
    }

    // Game Controller
    const controller = {
      increaseSpeed : false,
      decreaseSpeed : false,
      rotateLeft : false,
      rotateRight : false,

      listen: function(command){
        let isPressed = command.type === 'keydown'?  true : false

        switch(command.keyCode){
          case 87:
            controller.increaseSpeed = isPressed
            break
          case 65:
            controller.rotateLeft = isPressed
            break
          case 68:
            controller.rotateRight = isPressed
			      break
			    case 83:
			      controller.decreaseSpeed = isPressed
			      break
			  }
			}
    }

    document.addEventListener('keydown', controller.listen)
    document.addEventListener('keyup', controller.listen)


    function moveShip (ship)
    {
      if(controller.increaseSpeed){
        ship.thrusting = true
      }else{
        ship.thrusting = false
      }
      if(controller.decreaseSpeed){
        ship.decrease = true
      }else{
         ship.decrease = false
      }
      if(controller.rotateLeft){
        ship.rotation =  ship.turn  / 180 * Math.PI / (fps * 1.2)
      }
      if(controller.rotateRight){
        ship.rotation = - ship.turn / 180 * Math.PI / (fps * 1.2)
      }

      if(!controller.rotateLeft && !controller.rotateRight){
        ship.rotation = 0
      }

      ship.radian = ship.radian + ship.rotation
      ship.engine()
    }


    update()

    //Diconnect
    //socket.on('max-connections-error', (message) =>{
      //alert(message)
      //ocket.disconnect()
    //})
	</script>
</body>

</html>